{"version":3,"sources":["assets\\Script\\common\\pool.ts"],"names":[],"mappings":";;;;;;AACA;IAMI;;;;OAIG;IACH,cAAY,MAAe,EAAE,GAAgB;QAAhB,oBAAA,EAAA,QAAgB;QACzC,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAE3B,CAAC;IAED;;;;OAIG;IACK,mBAAI,GAAZ,UAAa,MAAe,EAAE,GAAgB;QAAhB,oBAAA,EAAA,QAAgB;QAE1C,IAAI,CAAC,IAAI,GAAG,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC;QAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YAC1B,IAAI,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO;YAC3C,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC;YACrB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,iBAAiB;SAC1C;IACL,CAAC;IAED;;;;OAIG;IACH,0BAAW,GAAX,UAAY,UAAmB,EAAE,IAAS;QAAT,qBAAA,EAAA,SAAS;QACtC,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,2BAA2B;YACnD,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;SAC3B;aAAM,EAAE,mDAAmD;YACxD,KAAK,GAAG,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SACvC;QACD,KAAK,CAAC,MAAM,GAAG,UAAU,CAAC,CAAC,cAAc;QACzC,IAAI,OAAO,GAAG,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC7C,IAAI,OAAO;YAAE,OAAO,CAAC,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,2BAA2B;QAC5E,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;QACpB,OAAO,KAAK,CAAA;IAChB,CAAC;IAGD;;;OAGG;IAEH,4BAAa,GAAb,UAAc,KAAc;QACxB,IAAI,KAAK,IAAE,KAAK,CAAC,IAAI,EAAE;YACnB,IAAI,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;gBAC/C,6BAA6B;gBAC7B,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC;gBACrB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,oDAAoD;aAC7E;iBACI;gBACD,KAAK,CAAC,OAAO,EAAE,CAAC;gBAChB,KAAK,CAAC,gBAAgB,EAAE,CAAC;gBACzB,KAAK,GAAG,IAAI,CAAC;aAChB;SACJ;IACL,CAAC;IAED;;OAEG;IACH,wBAAS,GAAT;QACI,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;IACtB,CAAC;IACL,WAAC;AAAD,CA/EA,AA+EC,IAAA","file":"","sourceRoot":"/","sourcesContent":["\nexport default class pool {\n\n    private pool: cc.NodePool;\n\n    private prefab: cc.Node;\n\n    /**\n     * \n     * @param prefab 预制体\n     * @param num 创建多少个\n     */\n    constructor(prefab: cc.Node, num: number = 10) {\n        prefab.active = false;\n        this.prefab = prefab;\n        this.init(prefab, num);\n\n    }\n\n    /**\n     * 初始化\n     * @param prefab 预制体\n     * @param num 创建多少个\n     */\n    private init(prefab: cc.Node, num: number = 10) {\n\n        this.pool = new cc.NodePool();\n        for (let i = 0; i < num; i++) {\n            let enemy = cc.instantiate(prefab); // 创建节点\n            enemy.active = false;\n            this.pool.put(enemy); // 通过 put 接口放入对象池\n        }\n    }\n\n    /**\n     * 创建\n     * @param parentNode 父节点\n     * @param data \n     */\n    createEnemy(parentNode: cc.Node, data = {}): cc.Node {\n        let enemy = null;\n        if (this.pool.size() > 0) { // 通过 size 接口判断对象池中是否有空闲的对象\n            enemy = this.pool.get();\n        } else { // 如果没有空闲对象，也就是对象池中备用对象不够时，我们就用 cc.instantiate 重新创建\n            enemy = cc.instantiate(this.prefab);\n        }\n        enemy.parent = parentNode; // 将生成的敌人加入节点树\n        let enemyTs = enemy.getComponent(enemy.name);\n        if (enemyTs) enemyTs.init && enemyTs.init(data); //接下来就可以调用 enemy 身上的脚本进行初始化\n        enemy.active = true;\n        return enemy\n    }\n\n\n    /**\n     * 回收\n     * @param enemy 节点\n     */\n\n    onEnemyKilled(enemy: cc.Node) {\n        if (enemy&&enemy.name) {\n            if (this.prefab && enemy.name == this.prefab.name) {\n                //     // enemy 应该是一个 cc.Node\n                enemy.active = false;\n                this.pool.put(enemy); // 和初始化时的方法一样，将节点放进对象池，这个方法会同时调用节点的 removeFromParent\n            }\n            else {\n                enemy.destroy();\n                enemy.removeFromParent();\n                enemy = null;\n            }\n        }\n    }\n\n    /**\n     * 清理对象池\n     */\n    clearPool() {\n        this.pool.clear();\n    }\n}\n"]}